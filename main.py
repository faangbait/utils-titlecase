"""
A Utility Function to Title Case Strings
Copyright (C) 2021 Limitless Interactive, LLC

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""

import re

stopwords = [
    "a", "an", "the",
    "and", "but", "by", "nor", "or", "so", "yet",
    "about", "above", "across", "after", "against", "along", "among", "around", "at", "before",
    "behind", "between", "beyond", "but", "by", "concerning", "despite", "down", "during",
    "except", "following", "for", "from", "in", "including", "into", "like", "near", "of",
    "off", "on", "out", "over", "plus", "since", "through", "throughout", "to", "towards",
    "under", "until", "up", "upon", "with", "within", "without"
    ] # "Stop words" are only capitalized when they are the first word in the title


def toTitleCase(raw: str) -> str:
    """
    Returns a string matching AP Style Guide standards for Titles

    :param raw: A non-normalized string
    :return: A normalized title case string
    """

    result = ""

    fragments = re.split(r'(\".*?\")|(\'.*?\')|(“.*?”)|(‘.*?’)', raw)

    for fragment in fragments:  # Treat and re-assemble all fragments
        if fragment:  # skip empty matches generated by the OR in regex
            fragString = ""
            tokens = fragment.split();  # Break string into individual words

            if tokens:
                for word in tokens:  # Check each word


                    punct = word[-1]  # Check for trailing punctuation mark
                    if punct.isalpha():
                        punct = ""
                    else:
                        word = word[:-1]

                    roman_numerals = re.match(r'^(?=[MDCLXVI])M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$', word.upper())

                    if word.lower() in stopwords:  # if it is excluded,
                        fragString += word.lower() + punct + " "  # make it lowercase
                    elif roman_numerals:  # if it is a roman numeral
                        fragString += roman_numerals.group() + punct + " "
                    else: # otherwise...
                        fragString += word.capitalize() + punct + " "  # capitalize it

                cap = 1
                if not fragString[0].isalpha():
                    cap = 2

                result += (fragString[:cap].upper() + fragString[cap:]).strip() + " "

    return (result[:1].upper() + result[1:]).strip()  # Capitalize first letter and strip trailing space
